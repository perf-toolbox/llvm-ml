load(
    "@bazel_tools//tools/build_defs/repo:utils.bzl",
    "patch",
    "update_attrs",
    "workspace_and_buildfile",
)

_common_attrs = {
    "path": attr.string(
        mandatory=True,
        doc = "Path to local repository",
    ),
    "patches": attr.label_list(
      default = [],
      doc =
          "A list of files that are to be applied as patches after " +
          "extracting the archive. By default, it uses the Bazel-native patch implementation " +
          "which doesn't support fuzz match and binary patch, but Bazel will fall back to use " +
          "patch command line tool if `patch_tool` attribute is specified or there are " +
          "arguments other than `-p` in `patch_args` attribute.",
    ),
    "patch_tool": attr.string(
        default = "",
        doc = "The patch(1) utility to use. If this is specified, Bazel will use the specified " +
              "patch tool instead of the Bazel-native patch implementation.",
    ),
    "patch_args": attr.string_list(
        default = ["-p0"],
        doc =
            "The arguments given to the patch tool. Defaults to -p0, " +
            "however -p1 will usually be needed for patches generated by " +
            "git. If multiple -p arguments are specified, the last one will take effect." +
            "If arguments other than -p are specified, Bazel will fall back to use patch " +
            "command line tool instead of the Bazel-native patch implementation. When falling " +
            "back to patch command line tool and patch_tool attribute is not specified, " +
            "`patch` will be used.",
    ),
    "patch_cmds": attr.string_list(
        default = [],
        doc = "Sequence of Bash commands to be applied on Linux/Macos after patches are applied.",
    ),
    "patch_cmds_win": attr.string_list(
        default = [],
        doc = "Sequence of Powershell commands to be applied on Windows after patches are " +
              "applied. If this attribute is not set, patch_cmds will be executed on Windows, " +
              "which requires Bash binary to exist.",
    ),
    "build_file": attr.label(
        allow_single_file = True,
        doc =
            "The file to use as the BUILD file for this repository." +
            "This attribute is an absolute label (use '@//' for the main " +
            "repo). The file does not need to be named BUILD, but can " +
            "be (something like BUILD.new-repo-name may work well for " +
            "distinguishing it from the repository's actual BUILD files. ",
    ),
    "build_file_content": attr.string(
        doc =
            "The content for the BUILD file for this repository. ",
    ),
    "workspace_file": attr.label(
        doc =
            "The file to use as the `WORKSPACE` file for this repository. " +
            "Either `workspace_file` or `workspace_file_content` can be " +
            "specified, or neither, but not both.",
    ),
    "workspace_file_content": attr.string(
        doc =
            "The content for the WORKSPACE file for this repository. " +
            "Either `workspace_file` or `workspace_file_content` can be " +
            "specified, or neither, but not both.",
    ),
}

def _impl(ctx):
    if ctx.attr.build_file and ctx.attr.build_file_content:
        fail("Only one of build_file and build_file_content can be provided.")

    repo_path = str(ctx.path(Label("//:BUILD")).dirname) + "/" + ctx.attr.path

    _patch_args = []
    for arg in ctx.attr.patch_args:
      _patch_args.append(arg)

    _patch_args.append("-d")
    _patch_args.append(repo_path)

    if ctx.path(repo_path + "/.git").exists:
      ctx.execute(["bash", "-c", "cd " + repo_path + " && git reset --hard HEAD"])

    workspace_and_buildfile(ctx)
    patch(ctx, patch_args=_patch_args)

    for name in ctx.path(repo_path).readdir():
      if not ctx.path(name.basename).exists:
        ctx.symlink(repo_path + "/" + name.basename, name.basename)
    
    return update_attrs(ctx.attr, _common_attrs.keys(), {})

local_patched_repository = repository_rule(
    implementation=_impl,
    attrs = _common_attrs,
    local = True
)
